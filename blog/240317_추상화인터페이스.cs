/*
추상 클래스
확장해야 함: 추상 클래스가 선언되면, 그것을 상속하는 모든 클래스는 추상 메소드에 대한 구현을 제공해야 합니다. 하지만, 추상 클래스 안의 비추상 메소드는 반드시 오버라이드할 필요는 없습니다(하지만 오버라이드할 수는 있습니다).
부분 구현: 추상 클래스는 완전히 구현된(비추상) 메소드와 구현되지 않은 추상 메소드를 혼합해서 포함할 수 있습니다. 상속받는 클래스는 추상 메소드만 구현해야 하며, 필요에 따라 구현된 메소드를 오버라이드할 수도 있습니다.

인터페이스
구현해야 함: 인터페이스가 선언되면, 그 인터페이스를 구현하는 모든 클래스는 모든 메소드에 대한 구현을 제공해야 합니다. 인터페이스는 구현 없이 메소드들을 선언만 하므로, 이를 계약이라고 합니다. 따라서, 추상 클래스와 달리 인터페이스는 인터페이스에 선언된 모든 메소드를 구현하는 클래스가 필요합니다.
구현 없음: 인터페이스는 선언된 모든 메소드에 대해 어떠한 구현도 포함하지 않으므로, 구현 클래스는 인터페이스에 정의된 모든 메소드에 대해 구체적인 구현을 제공해야 합니다.

핵심 정리
추상 클래스: 하위 클래스가 추상 메소드를 구현해야 합니다. 추상 클래스의 비추상 메소드는 오버라이드할 필요는 없습니다.
인터페이스: 구현 클래스는 선언된 모든 메소드를 정의해야 합니다. 인터페이스는 구현을 제공하지 않으므로 "재정의"가 아니라, 구현 클래스가 인터페이스의 메소드 시그니처를 준수해야 합니다.

요약하자면, 추상 클래스와 인터페이스 모두 그들의 "완성되지 않은" 부분(추상 클래스의 추상 메소드와 인터페이스의 모든 메소드)을 하위 클래스나 구현 클래스에서 구현해야 합니다. 차이점은 이 "완성되지 않은" 부분의 성격에 있습니다: 추상 클래스는 추상 메소드와 비추상 메소드를 혼합할 수 있지만, 인터페이스는 구현 없이 메소드 선언만 가질 수 있습니다.

//인터페이스
//추상클래스의 일종으로 특징이 동일.
//함수에 대한 선언만 하고 이를 포함하는 클래스에서 구체화한 다음 사용
// 추상화와 인터페이스의 공통점 : 함수에 대한 선언만 정의. 자식에서 구체화
// 인터페이스는 다중상속을 허용해 준다.
// 상속 : 사과는 과일이다? 과일은 사과이다.? << 뭐가 정답인가? 전자의 경우가 맞기 때문에 그럼 상속..>  사과는 과일이다? 그럼상속...뭔소리?...
// 어쩔때 추상을 쓰고 어쩔떄 인터페이스를 써야한다고 한다면 
//인터페이스는 다중상속을 허용
*/
public abstract class Vehicle
{
    public abstract void Drive(); // 하위 클래스에서 구현해야 합니다.

    public void Start()
    {
        Console.WriteLine("차량이 시작되었습니다.");
        // 이 메소드는 구현되어 있으며, 하위 클래스에서 반드시 오버라이드할 필요는 없습니다.
    }
}

public class Car : Vehicle
{
    public override void Drive()
    {
        Console.WriteLine("자동차가 주행 중입니다.");
        // 여기서 추상 메소드 Drive가 구현되었습니다.
    }
}

public interface IVehicle
{
    void Drive(); // 이 인터페이스를 구현하는 모든 클래스에서 구현해야 합니다.
}

public class Bicycle : IVehicle
{
    public void Drive()
    {
        Console.WriteLine("자전거가 페달을 밟고 있습니다.");
        // 여기서 인터페이스 메소드 Drive가 구현되었습니다.
    }
}